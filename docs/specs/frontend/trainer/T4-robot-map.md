# æ¨¡å—å¼€å‘è§„æ ¼ä¹¦ï¼šT4 æœºå™¨äººåœ°å›¾ç»„ä»¶

## æ–‡æ¡£ä¿¡æ¯
| é¡¹ç›® | å†…å®¹ |
|-----|------|
| æ¨¡å—ID | T4 |
| æ¨¡å—åç§° | RobotMap - æœºå™¨äººåœ°å›¾ç»„ä»¶ |
| ç‰ˆæœ¬ | 1.0 |
| æ—¥æœŸ | 2026å¹´1æœˆ |
| çŠ¶æ€ | è§„åˆ’ä¸­ |
| å‰ç½®ä¾èµ– | G4æœºå™¨äººAPIã€F1æ•°æ®æ¨¡å‹ |

---

## 1. æ¨¡å—æ¦‚è¿°

### 1.1 èŒè´£æè¿°

RobotMapç»„ä»¶è´Ÿè´£åœ¨äºŒç»´åœ°å›¾ä¸Šå®æ—¶å±•ç¤ºæœºå™¨äººä½ç½®ã€çŠ¶æ€å’Œè¿åŠ¨è½¨è¿¹ï¼Œæ”¯æŒæ¥¼å±‚åˆ‡æ¢ã€åŒºåŸŸæ ‡æ³¨ã€æœºå™¨äººé€‰ä¸­äº¤äº’ç­‰åŠŸèƒ½ã€‚æ˜¯è®­ç»ƒå·¥ä½œå°çš„æ ¸å¿ƒå¯è§†åŒ–ç»„ä»¶ã€‚

### 1.2 åœ¨ç³»ç»Ÿä¸­çš„ä½ç½®

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    è®­ç»ƒå·¥ä½œå° (Trainer Workbench)            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ T1: Agent   â”‚  â”‚ T2: å¾…å¤„ç†  â”‚  â”‚ T3: åé¦ˆé¢æ¿        â”‚ â”‚
â”‚  â”‚ æ´»åŠ¨æµ      â”‚  â”‚ é˜Ÿåˆ—        â”‚  â”‚                     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚              â˜… T4: æœºå™¨äººåœ°å›¾ç»„ä»¶ â˜…                    â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚ â”‚
â”‚  â”‚  â”‚  æ¥¼å±‚å¹³é¢å›¾                                     â”‚   â”‚ â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”                 â”‚   â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ğŸ¤– R1 â”‚  â”‚ğŸ¤– R2 â”‚  â”‚ğŸ¤– R3 â”‚ â† æœºå™¨äººå›¾æ ‡    â”‚   â”‚ â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”˜                 â”‚   â”‚ â”‚
â”‚  â”‚  â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• â† è¿åŠ¨è½¨è¿¹       â”‚   â”‚ â”‚
â”‚  â”‚  â”‚  [åŒºåŸŸA] [åŒºåŸŸB] [åŒºåŸŸC]      â† åŒºåŸŸæ ‡æ³¨       â”‚   â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ â”‚
â”‚  â”‚  [æ¥¼å±‚é€‰æ‹©] [å›¾å±‚æ§åˆ¶] [ç¼©æ”¾æ§åˆ¶]                      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.3 åŠŸèƒ½æ¦‚è¿°

| åŠŸèƒ½ | æè¿° | ä¼˜å…ˆçº§ |
|-----|------|-------|
| åœ°å›¾æ¸²æŸ“ | åŠ è½½å¹¶æ¸²æŸ“æ¥¼å±‚å¹³é¢å›¾ | P0 |
| æœºå™¨äººä½ç½® | å®æ—¶æ˜¾ç¤ºæœºå™¨äººä½ç½®å›¾æ ‡ | P0 |
| çŠ¶æ€æŒ‡ç¤º | é€šè¿‡é¢œè‰²/åŠ¨ç”»æ˜¾ç¤ºæœºå™¨äººçŠ¶æ€ | P0 |
| æ¥¼å±‚åˆ‡æ¢ | åˆ‡æ¢ä¸åŒæ¥¼å±‚è§†å›¾ | P0 |
| åŒºåŸŸæ ‡æ³¨ | æ˜¾ç¤ºæ¸…æ´åŒºåŸŸè¾¹ç•Œ | P1 |
| è¿åŠ¨è½¨è¿¹ | æ˜¾ç¤ºæœºå™¨äººç§»åŠ¨è·¯å¾„ | P1 |
| æœºå™¨äººé€‰ä¸­ | ç‚¹å‡»é€‰ä¸­æœºå™¨äººæŸ¥çœ‹è¯¦æƒ… | P1 |
| ç¼©æ”¾å¹³ç§» | åœ°å›¾ç¼©æ”¾å’Œæ‹–æ‹½ | P1 |
| å›¾å±‚æ§åˆ¶ | æ§åˆ¶æ˜¾ç¤º/éšè—å›¾å±‚ | P2 |
| çƒ­åŠ›å›¾ | æ¸…æ´è¦†ç›–çƒ­åŠ›å›¾ | P2 |

---

## 2. UIè®¾è®¡

### 2.1 ç»„ä»¶å¸ƒå±€

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ å·¥å…·æ                                                           â”‚ â”‚
â”‚ â”‚ [æ¥¼å±‚: 1F â–¼] [å›¾å±‚ â–¼] [è½¨è¿¹: ON] [çƒ­åŠ›å›¾: OFF]    [ğŸ”+] [ğŸ”-] â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â” â”‚
â”‚ â”‚                                                             â”‚   â”‚ â”‚
â”‚ â”‚                      åœ°å›¾ç”»å¸ƒ                               â”‚ å›¾â”‚ â”‚
â”‚ â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚ ä¾‹â”‚ â”‚
â”‚ â”‚   â”‚                                                  â”‚     â”‚   â”‚ â”‚
â”‚ â”‚   â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”                                    â”‚     â”‚ ğŸŸ¢â”‚ â”‚
â”‚ â”‚   â”‚    â”‚ åŒºåŸŸA  â”‚         ğŸ¤–â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€              â”‚     â”‚å·¥ä½œâ”‚ â”‚
â”‚ â”‚   â”‚    â”‚        â”‚              æœºå™¨äººè½¨è¿¹             â”‚     â”‚   â”‚ â”‚
â”‚ â”‚   â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                    â”‚     â”‚ ğŸŸ¡â”‚ â”‚
â”‚ â”‚   â”‚                    ğŸ¤–                            â”‚     â”‚æš‚åœâ”‚ â”‚
â”‚ â”‚   â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚     â”‚   â”‚ â”‚
â”‚ â”‚   â”‚         â”‚    åŒºåŸŸB       â”‚                      â”‚     â”‚ ğŸ”´â”‚ â”‚
â”‚ â”‚   â”‚         â”‚                â”‚        ğŸ¤–            â”‚     â”‚æ•…éšœâ”‚ â”‚
â”‚ â”‚   â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚     â”‚   â”‚ â”‚
â”‚ â”‚   â”‚                                                  â”‚     â”‚ âšªâ”‚ â”‚
â”‚ â”‚   â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”                                    â”‚     â”‚ç¦»çº¿â”‚ â”‚
â”‚ â”‚   â”‚    â”‚ åŒºåŸŸC â”‚                                    â”‚     â”‚   â”‚ â”‚
â”‚ â”‚   â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”˜                      ğŸ”Œ            â”‚     â”‚ ğŸ”µâ”‚ â”‚
â”‚ â”‚   â”‚                              å……ç”µç«™              â”‚     â”‚å……ç”µâ”‚ â”‚
â”‚ â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚   â”‚ â”‚
â”‚ â”‚                                                             â”‚   â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”˜ â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ çŠ¶æ€æ : åœ¨çº¿æœºå™¨äºº: 5/6 | å·¥ä½œä¸­: 3 | å……ç”µä¸­: 2 | æ•…éšœ: 0      â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 æœºå™¨äººå›¾æ ‡è®¾è®¡

```
æœºå™¨äººå›¾æ ‡ï¼ˆSVGï¼‰:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                             â”‚
â”‚  å·¥ä½œä¸­ (working):     æš‚åœ (paused):       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”               â”Œâ”€â”€â”€â”€â”€â”              â”‚
â”‚  â”‚ ğŸ¤–  â”‚ + æ—‹è½¬åŠ¨ç”»    â”‚ ğŸ¤–  â”‚ + è„‰å†²åŠ¨ç”»  â”‚
â”‚  â”‚ â–‚â–‚â–‚ â”‚ (è¾¹æ¡†)       â”‚ â–â–â– â”‚ (è¾¹æ¡†)      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”˜ ç»¿è‰²          â””â”€â”€â”€â”€â”€â”˜ é»„è‰²         â”‚
â”‚                                             â”‚
â”‚  æ•…éšœ (error):         ç¦»çº¿ (offline):      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”               â”Œâ”€â”€â”€â”€â”€â”              â”‚
â”‚  â”‚ ğŸ¤–  â”‚ + é—ªçƒåŠ¨ç”»    â”‚ ğŸ¤–  â”‚ æ— åŠ¨ç”»      â”‚
â”‚  â”‚ âš ï¸  â”‚ (è­¦å‘Šå›¾æ ‡)    â”‚     â”‚ ç°è‰²åŠé€æ˜  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”˜ çº¢è‰²          â””â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                                             â”‚
â”‚  å……ç”µä¸­ (charging):    é€‰ä¸­çŠ¶æ€:            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”               â”Œâ”€â”€â”€â”€â”€â”              â”‚
â”‚  â”‚ ğŸ¤–  â”‚ + å……ç”µåŠ¨ç”»    â”‚ ğŸ¤–  â”‚ æ”¾å¤§1.2å€   â”‚
â”‚  â”‚ ğŸ”‹  â”‚ (ç”µæ± å›¾æ ‡)    â”‚â–ˆâ–ˆâ–ˆâ–ˆâ”‚ é«˜äº®è¾¹æ¡†    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”˜ è“è‰²          â””â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.3 åŒºåŸŸæ ·å¼

```css
/* åŒºåŸŸæ ·å¼å®šä¹‰ */
.zone {
  /* é»˜è®¤æ ·å¼ */
  fill: rgba(59, 130, 246, 0.1);      /* æµ…è“å¡«å…… */
  stroke: rgba(59, 130, 246, 0.5);    /* è“è‰²è¾¹æ¡† */
  stroke-width: 2;
}

.zone:hover {
  fill: rgba(59, 130, 246, 0.2);      /* æ‚¬åœåŠ æ·± */
}

.zone.cleaning {
  fill: rgba(34, 197, 94, 0.2);       /* æ¸…æ´ä¸­ - ç»¿è‰² */
  stroke: rgba(34, 197, 94, 0.7);
}

.zone.completed {
  fill: rgba(34, 197, 94, 0.1);       /* å·²å®Œæˆ - æµ…ç»¿ */
  stroke: rgba(34, 197, 94, 0.3);
}

.zone.pending {
  fill: rgba(250, 204, 21, 0.1);      /* å¾…æ¸…æ´ - é»„è‰² */
  stroke: rgba(250, 204, 21, 0.5);
}
```

### 2.4 è½¨è¿¹æ ·å¼

```css
/* è½¨è¿¹æ ·å¼ */
.trajectory {
  stroke: rgba(99, 102, 241, 0.6);    /* ç´«è‰² */
  stroke-width: 2;
  stroke-linecap: round;
  stroke-linejoin: round;
  fill: none;
}

.trajectory.recent {
  stroke: rgba(99, 102, 241, 0.8);    /* æœ€è¿‘è½¨è¿¹æ›´æ·± */
  stroke-width: 3;
}

.trajectory.historical {
  stroke: rgba(99, 102, 241, 0.3);    /* å†å²è½¨è¿¹æ›´æµ… */
  stroke-width: 1;
  stroke-dasharray: 4 2;              /* è™šçº¿ */
}
```

---

## 3. ç»„ä»¶æ¥å£

### 3.1 Propså®šä¹‰

```typescript
// components/RobotMap/types.ts

interface RobotMapProps {
  /** æ¥¼å®‡ID */
  buildingId: string;
  
  /** é»˜è®¤æ¥¼å±‚ID */
  defaultFloorId?: string;
  
  /** æœºå™¨äººåˆ—è¡¨ï¼ˆå®æ—¶æ›´æ–°ï¼‰ */
  robots: Robot[];
  
  /** åŒºåŸŸåˆ—è¡¨ */
  zones: Zone[];
  
  /** æ˜¯å¦æ˜¾ç¤ºè½¨è¿¹ */
  showTrajectory?: boolean;
  
  /** æ˜¯å¦æ˜¾ç¤ºçƒ­åŠ›å›¾ */
  showHeatmap?: boolean;
  
  /** é€‰ä¸­çš„æœºå™¨äººID */
  selectedRobotId?: string;
  
  /** æœºå™¨äººç‚¹å‡»å›è°ƒ */
  onRobotClick?: (robot: Robot) => void;
  
  /** åŒºåŸŸç‚¹å‡»å›è°ƒ */
  onZoneClick?: (zone: Zone) => void;
  
  /** æ¥¼å±‚åˆ‡æ¢å›è°ƒ */
  onFloorChange?: (floorId: string) => void;
  
  /** åœ°å›¾åŠ è½½å®Œæˆå›è°ƒ */
  onMapLoad?: () => void;
  
  /** å®¹å™¨æ ·å¼ */
  className?: string;
  
  /** å®¹å™¨é«˜åº¦ */
  height?: number | string;
  
  /** åˆ·æ–°é—´éš”ï¼ˆæ¯«ç§’ï¼‰ */
  refreshInterval?: number;
  
  /** æ˜¯å¦å¯ç”¨WebSocketå®æ—¶æ›´æ–° */
  enableRealtime?: boolean;
}

interface Robot {
  id: string;
  name: string;
  brand: 'gaoxian' | 'ecovacs' | 'other';
  status: RobotStatus;
  position: Position | null;
  battery_level: number;
  current_task_id?: string;
}

interface RobotStatus {
  state: 'idle' | 'working' | 'charging' | 'paused' | 'error' | 'offline';
  sub_state?: string;
  error_code?: string;
  error_message?: string;
}

interface Position {
  x: number;          // åœ°å›¾åæ ‡X
  y: number;          // åœ°å›¾åæ ‡Y
  heading: number;    // æœå‘è§’åº¦ï¼ˆ0-360ï¼‰
  floor_id: string;
  timestamp: string;
}

interface Zone {
  id: string;
  name: string;
  floor_id: string;
  zone_type: 'cleaning' | 'restricted' | 'charging';
  polygon: Point[];   // å¤šè¾¹å½¢é¡¶ç‚¹
  status?: 'pending' | 'cleaning' | 'completed';
  assigned_robot_id?: string;
}

interface Point {
  x: number;
  y: number;
}

interface Floor {
  id: string;
  name: string;
  building_id: string;
  floor_number: number;
  map_url: string;    // æ¥¼å±‚å¹³é¢å›¾URL
  map_width: number;  // åœ°å›¾å®½åº¦ï¼ˆåƒç´ ï¼‰
  map_height: number; // åœ°å›¾é«˜åº¦ï¼ˆåƒç´ ï¼‰
  scale: number;      // æ¯”ä¾‹å°ºï¼ˆåƒç´ /ç±³ï¼‰
}

interface Trajectory {
  robot_id: string;
  points: TrajectoryPoint[];
}

interface TrajectoryPoint {
  x: number;
  y: number;
  timestamp: string;
}

interface HeatmapData {
  floor_id: string;
  cells: HeatmapCell[];
}

interface HeatmapCell {
  x: number;
  y: number;
  value: number;      // 0-1, æ¸…æ´è¦†ç›–åº¦
}
```

### 3.2 æš´éœ²çš„æ–¹æ³•ï¼ˆRefï¼‰

```typescript
interface RobotMapRef {
  /** åˆ‡æ¢æ¥¼å±‚ */
  switchFloor: (floorId: string) => void;
  
  /** èšç„¦åˆ°æŒ‡å®šæœºå™¨äºº */
  focusRobot: (robotId: string) => void;
  
  /** èšç„¦åˆ°æŒ‡å®šåŒºåŸŸ */
  focusZone: (zoneId: string) => void;
  
  /** è®¾ç½®ç¼©æ”¾çº§åˆ« */
  setZoom: (level: number) => void;
  
  /** é‡ç½®è§†å›¾ */
  resetView: () => void;
  
  /** è·å–å½“å‰è§†å›¾çŠ¶æ€ */
  getViewState: () => ViewState;
  
  /** å¯¼å‡ºåœ°å›¾æˆªå›¾ */
  exportImage: () => Promise<Blob>;
}

interface ViewState {
  floorId: string;
  zoom: number;
  center: Point;
  bounds: {
    minX: number;
    maxX: number;
    minY: number;
    maxY: number;
  };
}
```

### 3.3 APIè°ƒç”¨

```typescript
// è·å–æ¥¼å±‚åˆ—è¡¨
GET /api/v1/spaces/buildings/{building_id}/floors

// è·å–æ¥¼å±‚åœ°å›¾è¯¦æƒ…
GET /api/v1/spaces/floors/{floor_id}

// è·å–æœºå™¨äººä½ç½®ï¼ˆå®æ—¶ï¼‰
GET /api/v1/robots?floor_id={floor_id}&include_position=true

// WebSocketå®æ—¶ä½ç½®æ¨é€
WS /api/v1/robots/ws/status

// è·å–æœºå™¨äººè½¨è¿¹
GET /api/v1/robots/{robot_id}/positions?start_time={}&end_time={}

// è·å–åŒºåŸŸåˆ—è¡¨
GET /api/v1/spaces/floors/{floor_id}/zones

// è·å–çƒ­åŠ›å›¾æ•°æ®
GET /api/v1/data/coverage-heatmap?floor_id={floor_id}&date={}
```

---

## 4. æ•°æ®æ¨¡å‹

### 4.1 åœ°å›¾çŠ¶æ€

```typescript
interface MapState {
  /** å½“å‰æ¥¼å±‚ */
  currentFloor: Floor | null;
  
  /** æ‰€æœ‰æ¥¼å±‚ */
  floors: Floor[];
  
  /** å½“å‰æ¥¼å±‚çš„æœºå™¨äºº */
  robots: Robot[];
  
  /** å½“å‰æ¥¼å±‚çš„åŒºåŸŸ */
  zones: Zone[];
  
  /** æœºå™¨äººè½¨è¿¹ */
  trajectories: Map<string, Trajectory>;
  
  /** çƒ­åŠ›å›¾æ•°æ® */
  heatmap: HeatmapData | null;
  
  /** é€‰ä¸­çš„æœºå™¨äºº */
  selectedRobotId: string | null;
  
  /** è§†å›¾çŠ¶æ€ */
  viewState: ViewState;
  
  /** å›¾å±‚æ˜¾ç¤ºæ§åˆ¶ */
  layers: LayerVisibility;
  
  /** åŠ è½½çŠ¶æ€ */
  loading: boolean;
  
  /** é”™è¯¯ä¿¡æ¯ */
  error: string | null;
}

interface LayerVisibility {
  zones: boolean;
  robots: boolean;
  trajectories: boolean;
  heatmap: boolean;
  labels: boolean;
  chargingStations: boolean;
}
```

### 4.2 WebSocketæ¶ˆæ¯

```typescript
// æœºå™¨äººä½ç½®æ›´æ–°æ¶ˆæ¯
interface RobotPositionUpdate {
  type: 'position_update';
  robot_id: string;
  position: Position;
  status: RobotStatus;
  battery_level: number;
  timestamp: string;
}

// æœºå™¨äººçŠ¶æ€å˜åŒ–æ¶ˆæ¯
interface RobotStatusChange {
  type: 'status_change';
  robot_id: string;
  old_status: RobotStatus;
  new_status: RobotStatus;
  timestamp: string;
}

// åŒºåŸŸçŠ¶æ€æ›´æ–°æ¶ˆæ¯
interface ZoneStatusUpdate {
  type: 'zone_update';
  zone_id: string;
  status: 'pending' | 'cleaning' | 'completed';
  assigned_robot_id?: string;
  timestamp: string;
}

type WebSocketMessage = RobotPositionUpdate | RobotStatusChange | ZoneStatusUpdate;
```

---

## 5. å®ç°è¦æ±‚

### 5.1 æŠ€æœ¯æ ˆ

| æŠ€æœ¯ | ç‰ˆæœ¬ | ç”¨é€” |
|-----|------|------|
| React | 18+ | UIæ¡†æ¶ |
| TypeScript | 5.0+ | ç±»å‹å®‰å…¨ |
| Canvas/SVG | - | åœ°å›¾æ¸²æŸ“ |
| React-Konva | 18.2+ | CanvasæŠ½è±¡å±‚ |
| TailwindCSS | 3.4+ | æ ·å¼ |
| React Query | 5.0+ | æ•°æ®è·å– |
| Zustand | 4.0+ | çŠ¶æ€ç®¡ç† |

### 5.2 æ ¸å¿ƒå®ç°

#### 5.2.1 åœ°å›¾æ¸²æŸ“å¼•æ“

```typescript
// components/RobotMap/MapCanvas.tsx
import React, { useRef, useEffect, useCallback } from 'react';
import { Stage, Layer, Image, Group } from 'react-konva';
import useImage from 'use-image';
import { useMapStore } from './store';
import { RobotMarker } from './RobotMarker';
import { ZoneOverlay } from './ZoneOverlay';
import { TrajectoryLine } from './TrajectoryLine';
import { HeatmapOverlay } from './HeatmapOverlay';

interface MapCanvasProps {
  floor: Floor;
  robots: Robot[];
  zones: Zone[];
  trajectories: Map<string, Trajectory>;
  heatmap: HeatmapData | null;
  selectedRobotId: string | null;
  layers: LayerVisibility;
  onRobotClick: (robot: Robot) => void;
  onZoneClick: (zone: Zone) => void;
}

export const MapCanvas: React.FC<MapCanvasProps> = ({
  floor,
  robots,
  zones,
  trajectories,
  heatmap,
  selectedRobotId,
  layers,
  onRobotClick,
  onZoneClick,
}) => {
  const stageRef = useRef<any>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const [mapImage] = useImage(floor.map_url);
  
  const {
    zoom,
    position,
    setZoom,
    setPosition,
  } = useMapStore();

  // è®¡ç®—å®¹å™¨å°ºå¯¸
  const [containerSize, setContainerSize] = useState({ width: 800, height: 600 });

  useEffect(() => {
    const updateSize = () => {
      if (containerRef.current) {
        setContainerSize({
          width: containerRef.current.offsetWidth,
          height: containerRef.current.offsetHeight,
        });
      }
    };
    
    updateSize();
    window.addEventListener('resize', updateSize);
    return () => window.removeEventListener('resize', updateSize);
  }, []);

  // ç¼©æ”¾å¤„ç†
  const handleWheel = useCallback((e: any) => {
    e.evt.preventDefault();
    
    const stage = stageRef.current;
    const oldScale = stage.scaleX();
    const pointer = stage.getPointerPosition();
    
    const mousePointTo = {
      x: (pointer.x - stage.x()) / oldScale,
      y: (pointer.y - stage.y()) / oldScale,
    };
    
    const direction = e.evt.deltaY > 0 ? -1 : 1;
    const newScale = direction > 0 
      ? Math.min(oldScale * 1.1, 5)   // æœ€å¤§5å€
      : Math.max(oldScale / 1.1, 0.5); // æœ€å°0.5å€
    
    setZoom(newScale);
    
    const newPos = {
      x: pointer.x - mousePointTo.x * newScale,
      y: pointer.y - mousePointTo.y * newScale,
    };
    setPosition(newPos);
  }, [setZoom, setPosition]);

  // æ‹–æ‹½å¤„ç†
  const handleDragEnd = useCallback((e: any) => {
    setPosition({
      x: e.target.x(),
      y: e.target.y(),
    });
  }, [setPosition]);

  // è¿‡æ»¤å½“å‰æ¥¼å±‚çš„æ•°æ®
  const floorRobots = robots.filter(r => r.position?.floor_id === floor.id);
  const floorZones = zones.filter(z => z.floor_id === floor.id);

  return (
    <div ref={containerRef} className="w-full h-full">
      <Stage
        ref={stageRef}
        width={containerSize.width}
        height={containerSize.height}
        scaleX={zoom}
        scaleY={zoom}
        x={position.x}
        y={position.y}
        draggable
        onWheel={handleWheel}
        onDragEnd={handleDragEnd}
      >
        {/* åº•å›¾å±‚ */}
        <Layer>
          {mapImage && (
            <Image
              image={mapImage}
              width={floor.map_width}
              height={floor.map_height}
            />
          )}
        </Layer>

        {/* çƒ­åŠ›å›¾å±‚ */}
        {layers.heatmap && heatmap && (
          <Layer opacity={0.5}>
            <HeatmapOverlay data={heatmap} scale={floor.scale} />
          </Layer>
        )}

        {/* åŒºåŸŸå±‚ */}
        {layers.zones && (
          <Layer>
            {floorZones.map(zone => (
              <ZoneOverlay
                key={zone.id}
                zone={zone}
                onClick={() => onZoneClick(zone)}
              />
            ))}
          </Layer>
        )}

        {/* è½¨è¿¹å±‚ */}
        {layers.trajectories && (
          <Layer>
            {Array.from(trajectories.entries()).map(([robotId, trajectory]) => (
              <TrajectoryLine
                key={robotId}
                trajectory={trajectory}
                isSelected={robotId === selectedRobotId}
              />
            ))}
          </Layer>
        )}

        {/* æœºå™¨äººå±‚ */}
        {layers.robots && (
          <Layer>
            {floorRobots.map(robot => (
              <RobotMarker
                key={robot.id}
                robot={robot}
                isSelected={robot.id === selectedRobotId}
                onClick={() => onRobotClick(robot)}
              />
            ))}
          </Layer>
        )}
      </Stage>
    </div>
  );
};
```

#### 5.2.2 æœºå™¨äººæ ‡è®°ç»„ä»¶

```typescript
// components/RobotMap/RobotMarker.tsx
import React, { useMemo } from 'react';
import { Group, Circle, Text, Arrow } from 'react-konva';
import { Robot } from './types';

interface RobotMarkerProps {
  robot: Robot;
  isSelected: boolean;
  onClick: () => void;
}

const STATUS_COLORS: Record<string, string> = {
  idle: '#9CA3AF',      // ç°è‰²
  working: '#22C55E',   // ç»¿è‰²
  charging: '#3B82F6',  // è“è‰²
  paused: '#EAB308',    // é»„è‰²
  error: '#EF4444',     // çº¢è‰²
  offline: '#D1D5DB',   // æµ…ç°
};

const MARKER_SIZE = 24;
const SELECTED_SCALE = 1.3;

export const RobotMarker: React.FC<RobotMarkerProps> = ({
  robot,
  isSelected,
  onClick,
}) => {
  const position = robot.position;
  if (!position) return null;

  const color = STATUS_COLORS[robot.status.state] || STATUS_COLORS.offline;
  const scale = isSelected ? SELECTED_SCALE : 1;

  // è®¡ç®—æ–¹å‘ç®­å¤´
  const arrowPoints = useMemo(() => {
    const angle = (position.heading * Math.PI) / 180;
    const length = MARKER_SIZE * 0.8;
    return [
      0, 0,
      Math.sin(angle) * length,
      -Math.cos(angle) * length,
    ];
  }, [position.heading]);

  return (
    <Group
      x={position.x}
      y={position.y}
      scaleX={scale}
      scaleY={scale}
      onClick={onClick}
      onTap={onClick}
    >
      {/* é€‰ä¸­å…‰ç¯ */}
      {isSelected && (
        <Circle
          radius={MARKER_SIZE * 0.8}
          stroke={color}
          strokeWidth={3}
          dash={[5, 5]}
          opacity={0.5}
        />
      )}

      {/* ä¸»ä½“åœ† */}
      <Circle
        radius={MARKER_SIZE / 2}
        fill={color}
        stroke={isSelected ? '#FFFFFF' : color}
        strokeWidth={isSelected ? 3 : 1}
        shadowColor="black"
        shadowBlur={5}
        shadowOpacity={0.3}
      />

      {/* æ–¹å‘ç®­å¤´ */}
      <Arrow
        points={arrowPoints}
        fill="#FFFFFF"
        stroke="#FFFFFF"
        strokeWidth={2}
        pointerLength={6}
        pointerWidth={6}
      />

      {/* æœºå™¨äººåç§° */}
      <Text
        text={robot.name}
        fontSize={10}
        fill="#FFFFFF"
        fontStyle="bold"
        y={MARKER_SIZE / 2 + 4}
        offsetX={robot.name.length * 2.5}
      />

      {/* ç”µé‡æŒ‡ç¤ºï¼ˆä½ç”µé‡æ—¶æ˜¾ç¤ºï¼‰ */}
      {robot.battery_level < 20 && (
        <Text
          text={`ğŸ”‹${robot.battery_level}%`}
          fontSize={8}
          fill="#EF4444"
          y={MARKER_SIZE / 2 + 16}
          offsetX={15}
        />
      )}

      {/* çŠ¶æ€åŠ¨ç”» */}
      <StatusAnimation status={robot.status.state} />
    </Group>
  );
};

// çŠ¶æ€åŠ¨ç”»ç»„ä»¶
const StatusAnimation: React.FC<{ status: string }> = ({ status }) => {
  // å·¥ä½œä¸­ï¼šæ—‹è½¬åŠ¨ç”»
  // å……ç”µä¸­ï¼šè„‰å†²åŠ¨ç”»
  // é”™è¯¯ï¼šé—ªçƒåŠ¨ç”»
  // ä½¿ç”¨Konvaçš„Animationå®ç°
  return null; // ç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦ä½¿ç”¨Konva.Animation
};
```

#### 5.2.3 åŒºåŸŸè¦†ç›–å±‚

```typescript
// components/RobotMap/ZoneOverlay.tsx
import React from 'react';
import { Line, Text, Group } from 'react-konva';
import { Zone } from './types';

interface ZoneOverlayProps {
  zone: Zone;
  onClick: () => void;
}

const ZONE_COLORS: Record<string, { fill: string; stroke: string }> = {
  pending: {
    fill: 'rgba(250, 204, 21, 0.1)',
    stroke: 'rgba(250, 204, 21, 0.5)',
  },
  cleaning: {
    fill: 'rgba(34, 197, 94, 0.2)',
    stroke: 'rgba(34, 197, 94, 0.7)',
  },
  completed: {
    fill: 'rgba(34, 197, 94, 0.1)',
    stroke: 'rgba(34, 197, 94, 0.3)',
  },
  default: {
    fill: 'rgba(59, 130, 246, 0.1)',
    stroke: 'rgba(59, 130, 246, 0.5)',
  },
};

export const ZoneOverlay: React.FC<ZoneOverlayProps> = ({ zone, onClick }) => {
  const colors = ZONE_COLORS[zone.status || 'default'] || ZONE_COLORS.default;
  
  // å°†å¤šè¾¹å½¢é¡¶ç‚¹è½¬æ¢ä¸ºKonvaæ ¼å¼
  const points = zone.polygon.flatMap(p => [p.x, p.y]);
  
  // è®¡ç®—ä¸­å¿ƒç‚¹ç”¨äºæ˜¾ç¤ºæ ‡ç­¾
  const centerX = zone.polygon.reduce((sum, p) => sum + p.x, 0) / zone.polygon.length;
  const centerY = zone.polygon.reduce((sum, p) => sum + p.y, 0) / zone.polygon.length;

  return (
    <Group onClick={onClick} onTap={onClick}>
      {/* åŒºåŸŸå¤šè¾¹å½¢ */}
      <Line
        points={points}
        fill={colors.fill}
        stroke={colors.stroke}
        strokeWidth={2}
        closed
        hitStrokeWidth={10}
      />
      
      {/* åŒºåŸŸåç§°æ ‡ç­¾ */}
      <Text
        x={centerX}
        y={centerY}
        text={zone.name}
        fontSize={12}
        fill="#374151"
        fontStyle="bold"
        offsetX={zone.name.length * 3}
        offsetY={6}
      />
    </Group>
  );
};
```

#### 5.2.4 WebSocketå®æ—¶æ›´æ–°

```typescript
// hooks/useRobotPositionUpdates.ts
import { useEffect, useCallback } from 'react';
import { useQueryClient } from '@tanstack/react-query';
import { WebSocketMessage } from '../types';

export function useRobotPositionUpdates(floorId: string) {
  const queryClient = useQueryClient();
  
  const handleMessage = useCallback((message: WebSocketMessage) => {
    switch (message.type) {
      case 'position_update':
        // æ›´æ–°æœºå™¨äººä½ç½®ç¼“å­˜
        queryClient.setQueryData(
          ['robots', { floor_id: floorId }],
          (oldData: Robot[] | undefined) => {
            if (!oldData) return oldData;
            return oldData.map(robot => 
              robot.id === message.robot_id
                ? {
                    ...robot,
                    position: message.position,
                    status: message.status,
                    battery_level: message.battery_level,
                  }
                : robot
            );
          }
        );
        break;
        
      case 'status_change':
        // æ›´æ–°æœºå™¨äººçŠ¶æ€
        queryClient.setQueryData(
          ['robots', { floor_id: floorId }],
          (oldData: Robot[] | undefined) => {
            if (!oldData) return oldData;
            return oldData.map(robot =>
              robot.id === message.robot_id
                ? { ...robot, status: message.new_status }
                : robot
            );
          }
        );
        break;
        
      case 'zone_update':
        // æ›´æ–°åŒºåŸŸçŠ¶æ€
        queryClient.setQueryData(
          ['zones', { floor_id: floorId }],
          (oldData: Zone[] | undefined) => {
            if (!oldData) return oldData;
            return oldData.map(zone =>
              zone.id === message.zone_id
                ? {
                    ...zone,
                    status: message.status,
                    assigned_robot_id: message.assigned_robot_id,
                  }
                : zone
            );
          }
        );
        break;
    }
  }, [queryClient, floorId]);

  useEffect(() => {
    const ws = new WebSocket(
      `${process.env.NEXT_PUBLIC_WS_URL}/api/v1/robots/ws/status`
    );
    
    ws.onopen = () => {
      // è®¢é˜…æŒ‡å®šæ¥¼å±‚
      ws.send(JSON.stringify({
        action: 'subscribe',
        floor_id: floorId,
      }));
    };
    
    ws.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data) as WebSocketMessage;
        handleMessage(message);
      } catch (e) {
        console.error('Failed to parse WebSocket message:', e);
      }
    };
    
    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
    
    return () => {
      ws.close();
    };
  }, [floorId, handleMessage]);
}
```

#### 5.2.5 ä¸»ç»„ä»¶

```typescript
// components/RobotMap/index.tsx
import React, { useRef, useImperativeHandle, forwardRef } from 'react';
import { useQuery } from '@tanstack/react-query';
import { MapCanvas } from './MapCanvas';
import { MapToolbar } from './MapToolbar';
import { MapLegend } from './MapLegend';
import { MapStatusBar } from './MapStatusBar';
import { useMapStore } from './store';
import { useRobotPositionUpdates } from '../../hooks/useRobotPositionUpdates';
import { RobotMapProps, RobotMapRef, Floor, Robot, Zone, Trajectory } from './types';
import { fetchFloors, fetchRobots, fetchZones, fetchTrajectory, fetchHeatmap } from '../../api';

export const RobotMap = forwardRef<RobotMapRef, RobotMapProps>(({
  buildingId,
  defaultFloorId,
  robots: externalRobots,
  zones: externalZones,
  showTrajectory = false,
  showHeatmap = false,
  selectedRobotId,
  onRobotClick,
  onZoneClick,
  onFloorChange,
  onMapLoad,
  className,
  height = 600,
  refreshInterval = 5000,
  enableRealtime = true,
}, ref) => {
  const mapCanvasRef = useRef<any>(null);
  
  const {
    currentFloorId,
    setCurrentFloorId,
    layers,
    setLayers,
    zoom,
    setZoom,
    resetView,
  } = useMapStore();

  // è·å–æ¥¼å±‚åˆ—è¡¨
  const { data: floors = [] } = useQuery({
    queryKey: ['floors', buildingId],
    queryFn: () => fetchFloors(buildingId),
    onSuccess: (data) => {
      if (!currentFloorId && data.length > 0) {
        const floor = defaultFloorId 
          ? data.find(f => f.id === defaultFloorId) 
          : data[0];
        if (floor) {
          setCurrentFloorId(floor.id);
        }
      }
    },
  });

  const currentFloor = floors.find(f => f.id === currentFloorId);

  // è·å–æœºå™¨äººï¼ˆå¦‚æœæ²¡æœ‰å¤–éƒ¨ä¼ å…¥ï¼‰
  const { data: fetchedRobots = [] } = useQuery({
    queryKey: ['robots', { floor_id: currentFloorId }],
    queryFn: () => fetchRobots({ floor_id: currentFloorId, include_position: true }),
    enabled: !externalRobots && !!currentFloorId,
    refetchInterval: refreshInterval,
  });

  // è·å–åŒºåŸŸï¼ˆå¦‚æœæ²¡æœ‰å¤–éƒ¨ä¼ å…¥ï¼‰
  const { data: fetchedZones = [] } = useQuery({
    queryKey: ['zones', { floor_id: currentFloorId }],
    queryFn: () => fetchZones(currentFloorId!),
    enabled: !externalZones && !!currentFloorId,
  });

  const robots = externalRobots || fetchedRobots;
  const zones = externalZones || fetchedZones;

  // WebSocketå®æ—¶æ›´æ–°
  if (enableRealtime && currentFloorId) {
    useRobotPositionUpdates(currentFloorId);
  }

  // è·å–è½¨è¿¹æ•°æ®
  const { data: trajectories = new Map() } = useQuery({
    queryKey: ['trajectories', selectedRobotId],
    queryFn: async () => {
      if (!selectedRobotId) return new Map<string, Trajectory>();
      const trajectory = await fetchTrajectory(selectedRobotId, {
        start_time: new Date(Date.now() - 3600000).toISOString(), // æœ€è¿‘1å°æ—¶
        end_time: new Date().toISOString(),
      });
      return new Map([[selectedRobotId, trajectory]]);
    },
    enabled: showTrajectory && !!selectedRobotId,
  });

  // è·å–çƒ­åŠ›å›¾æ•°æ®
  const { data: heatmap } = useQuery({
    queryKey: ['heatmap', currentFloorId],
    queryFn: () => fetchHeatmap(currentFloorId!, new Date().toISOString().split('T')[0]),
    enabled: showHeatmap && !!currentFloorId,
  });

  // æš´éœ²æ–¹æ³•ç»™çˆ¶ç»„ä»¶
  useImperativeHandle(ref, () => ({
    switchFloor: (floorId: string) => {
      setCurrentFloorId(floorId);
      onFloorChange?.(floorId);
    },
    focusRobot: (robotId: string) => {
      const robot = robots.find(r => r.id === robotId);
      if (robot?.position) {
        // å¹³ç§»åˆ°æœºå™¨äººä½ç½®
        mapCanvasRef.current?.centerOn(robot.position.x, robot.position.y);
      }
    },
    focusZone: (zoneId: string) => {
      const zone = zones.find(z => z.id === zoneId);
      if (zone && zone.polygon.length > 0) {
        const centerX = zone.polygon.reduce((s, p) => s + p.x, 0) / zone.polygon.length;
        const centerY = zone.polygon.reduce((s, p) => s + p.y, 0) / zone.polygon.length;
        mapCanvasRef.current?.centerOn(centerX, centerY);
      }
    },
    setZoom,
    resetView,
    getViewState: () => ({
      floorId: currentFloorId!,
      zoom,
      center: { x: 0, y: 0 },
      bounds: { minX: 0, maxX: 0, minY: 0, maxY: 0 },
    }),
    exportImage: async () => {
      const stage = mapCanvasRef.current?.getStage();
      if (!stage) throw new Error('Stage not ready');
      const dataUrl = stage.toDataURL({ pixelRatio: 2 });
      const res = await fetch(dataUrl);
      return res.blob();
    },
  }));

  // ç»Ÿè®¡æ•°æ®
  const stats = {
    total: robots.length,
    online: robots.filter(r => r.status.state !== 'offline').length,
    working: robots.filter(r => r.status.state === 'working').length,
    charging: robots.filter(r => r.status.state === 'charging').length,
    error: robots.filter(r => r.status.state === 'error').length,
  };

  return (
    <div className={`flex flex-col ${className}`} style={{ height }}>
      {/* å·¥å…·æ  */}
      <MapToolbar
        floors={floors}
        currentFloorId={currentFloorId}
        onFloorChange={(id) => {
          setCurrentFloorId(id);
          onFloorChange?.(id);
        }}
        layers={layers}
        onLayersChange={setLayers}
        zoom={zoom}
        onZoomChange={setZoom}
        onReset={resetView}
      />

      {/* åœ°å›¾ä¸»ä½“ */}
      <div className="flex-1 relative bg-gray-100">
        {currentFloor ? (
          <MapCanvas
            ref={mapCanvasRef}
            floor={currentFloor}
            robots={robots}
            zones={zones}
            trajectories={trajectories}
            heatmap={heatmap || null}
            selectedRobotId={selectedRobotId || null}
            layers={layers}
            onRobotClick={(robot) => onRobotClick?.(robot)}
            onZoneClick={(zone) => onZoneClick?.(zone)}
          />
        ) : (
          <div className="flex items-center justify-center h-full text-gray-500">
            è¯·é€‰æ‹©æ¥¼å±‚
          </div>
        )}

        {/* å›¾ä¾‹ */}
        <MapLegend className="absolute top-4 right-4" />
      </div>

      {/* çŠ¶æ€æ  */}
      <MapStatusBar stats={stats} />
    </div>
  );
});

RobotMap.displayName = 'RobotMap';

export default RobotMap;
```

---

## 6. æµ‹è¯•è¦æ±‚

### 6.1 å•å…ƒæµ‹è¯•

```typescript
// components/RobotMap/__tests__/RobotMap.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { RobotMap } from '../index';

const mockFloors: Floor[] = [
  {
    id: 'floor-1',
    name: '1F',
    building_id: 'building-1',
    floor_number: 1,
    map_url: '/maps/floor1.png',
    map_width: 1000,
    map_height: 800,
    scale: 100,
  },
];

const mockRobots: Robot[] = [
  {
    id: 'robot-1',
    name: 'R1',
    brand: 'gaoxian',
    status: { state: 'working' },
    position: { x: 100, y: 200, heading: 45, floor_id: 'floor-1', timestamp: '' },
    battery_level: 85,
  },
  {
    id: 'robot-2',
    name: 'R2',
    brand: 'ecovacs',
    status: { state: 'charging' },
    position: { x: 300, y: 400, heading: 90, floor_id: 'floor-1', timestamp: '' },
    battery_level: 45,
  },
];

const mockZones: Zone[] = [
  {
    id: 'zone-1',
    name: 'Area A',
    floor_id: 'floor-1',
    zone_type: 'cleaning',
    polygon: [{ x: 0, y: 0 }, { x: 100, y: 0 }, { x: 100, y: 100 }, { x: 0, y: 100 }],
    status: 'cleaning',
  },
];

const queryClient = new QueryClient({
  defaultOptions: { queries: { retry: false } },
});

const wrapper = ({ children }: { children: React.ReactNode }) => (
  <QueryClientProvider client={queryClient}>
    {children}
  </QueryClientProvider>
);

describe('RobotMap', () => {
  beforeEach(() => {
    queryClient.clear();
  });

  test('renders map with robots', async () => {
    render(
      <RobotMap
        buildingId="building-1"
        robots={mockRobots}
        zones={mockZones}
      />,
      { wrapper }
    );

    // ç­‰å¾…åœ°å›¾åŠ è½½
    await waitFor(() => {
      expect(screen.getByText('åœ¨çº¿æœºå™¨äºº:')).toBeInTheDocument();
    });
  });

  test('handles floor change', async () => {
    const onFloorChange = jest.fn();
    
    render(
      <RobotMap
        buildingId="building-1"
        robots={mockRobots}
        zones={mockZones}
        onFloorChange={onFloorChange}
      />,
      { wrapper }
    );

    // æ¨¡æ‹Ÿæ¥¼å±‚åˆ‡æ¢
    // ...
  });

  test('handles robot click', async () => {
    const onRobotClick = jest.fn();
    
    render(
      <RobotMap
        buildingId="building-1"
        robots={mockRobots}
        zones={mockZones}
        onRobotClick={onRobotClick}
      />,
      { wrapper }
    );

    // ç”±äºä½¿ç”¨Canvasï¼Œéœ€è¦æ¨¡æ‹ŸKonvaäº‹ä»¶
    // ...
  });

  test('displays correct robot status colors', () => {
    // æµ‹è¯•ä¸åŒçŠ¶æ€çš„æœºå™¨äººæ˜¾ç¤ºæ­£ç¡®çš„é¢œè‰²
  });

  test('displays zone overlays', () => {
    // æµ‹è¯•åŒºåŸŸè¦†ç›–å±‚æ­£ç¡®æ˜¾ç¤º
  });

  test('handles zoom controls', () => {
    // æµ‹è¯•ç¼©æ”¾æ§åˆ¶
  });

  test('handles layer visibility toggle', () => {
    // æµ‹è¯•å›¾å±‚æ˜¾ç¤º/éšè—
  });
});
```

### 6.2 é›†æˆæµ‹è¯•

```typescript
// components/RobotMap/__tests__/RobotMap.integration.test.tsx
describe('RobotMap Integration', () => {
  test('receives WebSocket updates and updates robot positions', async () => {
    // æµ‹è¯•WebSocketå®æ—¶æ›´æ–°
  });

  test('loads trajectory when robot is selected', async () => {
    // æµ‹è¯•é€‰ä¸­æœºå™¨äººæ—¶åŠ è½½è½¨è¿¹
  });

  test('loads heatmap data when enabled', async () => {
    // æµ‹è¯•çƒ­åŠ›å›¾åŠ è½½
  });
});
```

---

## 7. éªŒæ”¶æ ‡å‡†

### 7.1 åŠŸèƒ½éªŒæ”¶

| éªŒæ”¶é¡¹ | éªŒæ”¶æ ‡å‡† | ä¼˜å…ˆçº§ |
|-------|---------|-------|
| åœ°å›¾æ¸²æŸ“ | æ¥¼å±‚å¹³é¢å›¾æ­£ç¡®åŠ è½½å¹¶æ˜¾ç¤º | P0 |
| æœºå™¨äººæ˜¾ç¤º | æ‰€æœ‰åœ¨çº¿æœºå™¨äººæ­£ç¡®æ˜¾ç¤ºåœ¨åœ°å›¾ä¸Š | P0 |
| çŠ¶æ€é¢œè‰² | æœºå™¨äººçŠ¶æ€é€šè¿‡é¢œè‰²æ­£ç¡®åŒºåˆ† | P0 |
| å®æ—¶æ›´æ–° | æœºå™¨äººä½ç½®å®æ—¶æ›´æ–°ï¼ˆå»¶è¿Ÿ<1ç§’ï¼‰ | P0 |
| æ¥¼å±‚åˆ‡æ¢ | ç‚¹å‡»æ¥¼å±‚é€‰æ‹©å™¨å¯åˆ‡æ¢æ¥¼å±‚ | P0 |
| ç¼©æ”¾å¹³ç§» | é¼ æ ‡æ»šè½®ç¼©æ”¾ã€æ‹–æ‹½å¹³ç§»æ­£å¸¸å·¥ä½œ | P1 |
| æœºå™¨äººç‚¹å‡» | ç‚¹å‡»æœºå™¨äººè§¦å‘å›è°ƒå¹¶é«˜äº®æ˜¾ç¤º | P1 |
| åŒºåŸŸæ˜¾ç¤º | åŒºåŸŸè¾¹ç•Œå’ŒçŠ¶æ€æ­£ç¡®æ˜¾ç¤º | P1 |
| è½¨è¿¹æ˜¾ç¤º | é€‰ä¸­æœºå™¨äººæ—¶æ˜¾ç¤ºè¿åŠ¨è½¨è¿¹ | P1 |
| çƒ­åŠ›å›¾ | çƒ­åŠ›å›¾æ­£ç¡®å åŠ åœ¨åœ°å›¾ä¸Š | P2 |

### 7.2 æ€§èƒ½è¦æ±‚

| æŒ‡æ ‡ | è¦æ±‚ | æµ‹é‡æ–¹æ³• |
|-----|------|---------|
| é¦–æ¬¡æ¸²æŸ“ | < 500ms | Performance API |
| ä½ç½®æ›´æ–°å¸§ç‡ | â‰¥ 30fps | åŠ¨ç”»å¸§è®¡æ•° |
| WebSocketå»¶è¿Ÿ | < 100ms | ç«¯åˆ°ç«¯æ—¶é—´æˆ³ |
| å†…å­˜å ç”¨ | < 100MB | Chrome DevTools |
| æ”¯æŒæœºå™¨äººæ•° | â‰¥ 50å° | å‹åŠ›æµ‹è¯• |

### 7.3 ä»£ç è´¨é‡

| è¦æ±‚ | æ ‡å‡† |
|-----|------|
| TypeScript | ä¸¥æ ¼æ¨¡å¼ï¼Œæ— anyç±»å‹ |
| æµ‹è¯•è¦†ç›– | æ ¸å¿ƒé€»è¾‘ > 80% |
| ç»„ä»¶æ‹†åˆ† | å•ç»„ä»¶ < 300è¡Œ |
| æ€§èƒ½ä¼˜åŒ– | ä½¿ç”¨React.memoã€useMemoã€useCallback |

---

## 8. ä¾èµ–è¯´æ˜

### 8.1 npmä¾èµ–

```json
{
  "dependencies": {
    "react": "^18.2.0",
    "react-konva": "^18.2.10",
    "konva": "^9.2.0",
    "use-image": "^1.1.1",
    "@tanstack/react-query": "^5.0.0",
    "zustand": "^4.4.0"
  },
  "devDependencies": {
    "@testing-library/react": "^14.0.0",
    "jest-canvas-mock": "^2.5.0"
  }
}
```

### 8.2 APIä¾èµ–

- G4: æœºå™¨äººAPIï¼ˆä½ç½®ã€çŠ¶æ€ï¼‰
- G2: ç©ºé—´APIï¼ˆæ¥¼å±‚ã€åŒºåŸŸï¼‰
- G6: æ•°æ®APIï¼ˆçƒ­åŠ›å›¾ï¼‰
- WebSocket: å®æ—¶ä½ç½®æ¨é€

---

*æ–‡æ¡£ç»“æŸ*
